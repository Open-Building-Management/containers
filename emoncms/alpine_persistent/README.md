# An alpine container with persistent storage

## changes with the initial alpine Dockerfile

- a oneshot s6 service called emoncms_pre to create the timeseries folders, fix permissions and run mysql_install_db if needed

- a oneshot s6 service called sql_ready initializes the emoncms database if needed and waits for mariadb to be running, before the workers can start

Using environnement variables, emoncms_pre.sh generates at startup the following conf files :
- /etc/my.cnf
- emoncms settings.ini
- config.cfg for backup module
- backup.ini PHP extension

Even if mariadb tables initialisation is done when the first user is created, as we are going to use something like docker compose, we need the database structure to be created before, and so we still use emoncmsdbupdate.php

## Some ENV vars are both used during buildtime and during runtime

ENV|Dockerfile|makefile (used during build)|emoncms_pre|mysql_ready|ARG
--|--|--|--|--|--
DAEMON|10||2||
WWW|9|X|2||
OEM_DIR|6||2|1|
EMONCMS_DIR|5|X|3||
EMONCMS_LOG_LOCATION|4||||
MQTT_CONF|1||7||
PHP_VER|2||||YES
PHP_CONF|2||3||YES

## real ENV vars, only used at runtime
ENV|Dockerfile|makefile (used during build)|emoncms_pre|mysql_ready|ARG
--|--|--|--|--|--
TZ|||1||
EMONCMS_DATADIR|||15||
TS|||1||
MYSQL_DATABASE|||1|3|
MYSQL_USER|||1|3|
MYSQL_PASSWORD|||1|1|
MQTT_USER|||2||
MQTT_PASSWORD|||2||
MQTT_HOST|||1||
MQTT_LOG_LEVEL|||1||


## changelog

### 29/09/2023

adding ARG BUILD_FROM

defining PHP_VER and PHP_CONF as ARG and no more as ENV, so we can modulate PHP_VER and PHP_CONF during build, in order to be able to build for alpine:3.18 without changing anything

```
docker build -t emoncms:alpine3.18 --build-arg="BUILD_FROM=alpine:3.18" --build-arg="TARGETPLATFORM=linux/amd64" --build-arg="PHP_VER=81" --build-arg="PHP_CONF=/etc/php81/conf.d" .
```

nota : PHP_CONF is also defined as an ENV at the end of the dockerfile as we use it in emoncms_pre

### 21/09/2023

solving timezone problem with the command `cp /usr/share/zoneinfo/$TZ /etc/localtime` in emoncms_pre

possibility to modulate mqtt log level :

```
docker run --rm -it -p 8081:80 -p 7883:1883 -e MQTT_LOG_LEVEL="error warning information notice" themis:alpine3.16
docker run --rm -it -p 8081:80 -p 7883:1883 -e MQTT_LOG_LEVEL=notice themis:alpine3.16
```

### 31/01/2024

#### adding ssl and https for secure operation

You can activate ssl on the emoncms standalone docker image using the new ENV vars : CRT_FILE and KEY_FILE

```
sudo docker run --rm -p 8081:80 -p 8082:443 -p 7883:1883 -v /etc/ssl/certs/bios:/cert -e CRT_FILE=/cert/alexjunk.crt -e KEY_FILE=/cert/alexjunk.key -it emoncms:alpine3.18
```
**USECASE : you want to access the service using the dns address on a computer of your local network : if your router doesn't support NAT loopback, you need to add an entry to the hosts file of each machine you want to use for browsing :**
```
my.domain.name  192.168.1.33
```
**This requires the container to be started with ssl enabled !** The reverse proxy mentioned just after has nothing to do with it. 

If you don't use a reverse proxy and which to access to your emoncms instance from the instance, you have to add a NAT/PAT rule on your internet router. This involves specifying an internal port and an external port for a local IP. All traffic on your `router's public address:external port` will be routed to the `local IP address:internal port`. 

#### about secure connexions

In all cases, [NGINX PROXY MANAGER](https://nginxproxymanager.com/), which is a reverse proxy, will enable you to access your services securely from the outside, even if these services only offer a non-secure connection. For example, the emoncms standalone docker container without ssl activated does not offer a secure connexion.

If you want to access your services securely from the outside, you need a dynamic domain name, for example supplied by noip or by duckdns. 

A valid domain name may be obtained via duckdns simply by logging in using a github account, which provides a token to be supplied when generating the associated certificates needed for securing the connection. 

Certificates consist of a pair of public and private keys.

To generate them using NGINX PROXY MANAGER, click on `SSL Certificates > Add SSl Certificate > Let's Encrypt`

![image](https://github.com/Open-Building-Management/containers/assets/24553739/a056e47b-6844-433c-b4af-ef92651e329b)

Fill the domain name, which can be a wildcard (*.my.domain.name), then choose the `DNS Challenge method, fill the credentials with your duckdns token, agree to the terms of service and save !

Please note that if you only wish to encrypt transactions on a local network, you don't need a valid domain name and self-signed certificates generated by openssl will do the trick but the connexion will be considered as non trusted.

The second step is to create a proxy host, using the domain name with `Websockest Support`, associating the certificate and choosing the `force SSL` option

![image](https://github.com/Open-Building-Management/containers/assets/24553739/93c2b7b7-4121-4edc-837e-8403c50ae450)

**The final stage is to adjust a NAT/PAT rule on your internet router so that the traffic on port 443 goes to the NGINX PROXY MANAGER.**
